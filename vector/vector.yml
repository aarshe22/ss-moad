# MOAD Vector Configuration
# Ensures all log-derived identifiers are join-compatible with MySQL schema

# ============================================================================
# SOURCES - Read-only log ingestion from NFS mounts
# ============================================================================

sources:
  # Tomcat logs - CM application
  tomcat_cm:
    type: file
    include:
      - /data/moad/logs/app1/usr/share/apache-tomcat-8.5.94/logs/catalina.out
    multiline:
      start_pattern: '^\d{4}-\d{2}-\d{2}'
      mode: continue_through
      condition_pattern: '^[[:space:]]'
      timeout_ms: 1000
    encoding:
      charset: utf8
    host_key: host

  # Tomcat logs - PFM application
  tomcat_pfm:
    type: file
    include:
      - /data/moad/logs/app2/usr/share/apache-tomcat-8.5.94/logs/catalina.out
    multiline:
      start_pattern: '^\d{4}-\d{2}-\d{2}'
      mode: continue_through
      condition_pattern: '^[[:space:]]'
      timeout_ms: 1000
    encoding:
      charset: utf8
    host_key: host

  # HAProxy logs - CM
  haproxy_cm:
    type: file
    include:
      - /data/moad/logs/app1/var/log/haproxy.log
    host_key: host

  # HAProxy logs - PFM
  haproxy_pfm:
    type: file
    include:
      - /data/moad/logs/app2/var/log/haproxy.log
    host_key: host

  # Postfix mail logs - CM
  mail_cm:
    type: file
    include:
      - /data/moad/logs/app1/var/log/mail.log
    host_key: host

  # Postfix mail logs - PFM
  mail_pfm:
    type: file
    include:
      - /data/moad/logs/app2/var/log/mail.log
    host_key: host

# ============================================================================
# TRANSFORMS - Event classification and identifier extraction
# ============================================================================

transforms:
  # Parse Tomcat logs and extract authentication events
  parse_tomcat_cm:
    type: remap
    inputs:
      - tomcat_cm
    source: |
      # Ensure .message is a string for all operations
      .message = string!(.message)
      
      # Parse timestamp (use parse_timestamp without ! to allow fallback)
      .timestamp = parse_timestamp(.message, format: "%Y-%m-%d %H:%M:%S") ?? now()
      
      # Extract log level
      if match(.message, r'ERROR') {
        .level = "error"
      } else if match(.message, r'WARN') {
        .level = "warn"
      } else if match(.message, r'INFO') {
        .level = "info"
      } else if match(.message, r'DEBUG') {
        .level = "debug"
      } else {
        .level = "unknown"
      }
      
      # Event type classification
      .event_type = "unknown"
      .event_category = "application"
      
      # Authentication events - extract join-compatible identifiers
      if match(.message, r'(?i)(login|authentication|auth|authenticate)') {
        .event_type = "authentication"
        .event_category = "security"
        
        # Extract username (normalized to match users.userName)
        .username = match(.message, r'(?:user|username|login)[\s:=]+([a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}|[a-zA-Z0-9._-]+)')
        if !is_null(.username) {
          .username = downcase(string!(.username))
          # Remove email domain if it's an email-style username
          .username_normalized = replace(.username, r'@.*$', "")
        }
        
        # Extract email (normalized to match users.email)
        .email = match(.message, r'([a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})')
        if !is_null(.email) {
          .email = downcase(string!(.email))
        }
        
        # Extract IP address (for users.lastKnownIP correlation)
        .client_ip = match(.message, r'\b(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\b')
        
        # Auth result (success/failed)
        .auth_result = match(.message, r'(?i)(success|successful|failed|failure|denied|invalid)')
        if is_null(.auth_result) {
          .auth_result = "unknown"
        }
        if match(string!(.auth_result), r'(?i)(success|successful)') {
          .auth_result = "success"
        } else if match(string!(.auth_result), r'(?i)(failed|failure|denied|invalid)') {
          .auth_result = "failed"
        }
        
        # Extract school identifier from URL or context
        .school_id = match(.message, r'(?:school|schoolId)[\s:=]+(\d+)')
        .school_subdomain = match(.message, r'https?://([a-z0-9-]+)\.schoolsoft\.(?:net|com)')
      }
      
      # PowerSchool integration events (ConsumerManager)
      if match(.message, r'(?i)(powerschool|consumer|sis|integration)') {
        .event_type = "powerschool_integration"
        .event_category = "integration"
        
        # Extract external SIS identity
        .sis_identity = match(.message, r'(?:sis|external|powerschool)[\s:=]+([a-zA-Z0-9._-]+)')
        
        # Extract email (for parents.email join)
        .email = match(.message, r'([a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})')
        if !is_null(.email) {
          .email = downcase(string!(.email))
        }
        
        # Extract student IDs (for students.id join)
        .student_ids = match(.message, r'(?:student|studentId)[\s:=]+(\d+)')
        if is_string(.student_ids) {
          .student_ids = [.student_ids]
        } else if is_null(.student_ids) {
          .student_ids = []
        }
        
        # Extract school ID (for studentSchool.schoolId join)
        .school_id = match(.message, r'(?:school|schoolId)[\s:=]+(\d+)')
        
        # Integration status
        .integration_status = match(.message, r'(?i)(success|failed|error|completed)')
        if is_null(.integration_status) {
          .integration_status = "unknown"
        }
      }
      
      # Conference events
      if match(.message, r'(?i)(conference|round|schedule|timeslot)') {
        .event_type = "conference"
        .event_category = "business"
        
        # Extract user ID (for users.id join)
        .user_id = match(.message, r'(?:user|userId)[\s:=]+(\d+)')
        
        # Extract school ID (for schools.id join)
        .school_id = match(.message, r'(?:school|schoolId)[\s:=]+(\d+)')
        
        # Extract student ID (for students.id join)
        .student_id = match(.message, r'(?:student|studentId)[\s:=]+(\d+)')
      }
      
      # Policy events
      if match(.message, r'(?i)(policy|policyresponse)') {
        .event_type = "policy"
        .event_category = "business"
        
        .user_id = match(.message, r'(?:user|userId)[\s:=]+(\d+)')
        .school_id = match(.message, r'(?:school|schoolId)[\s:=]+(\d+)')
        .student_id = match(.message, r'(?:student|studentId)[\s:=]+(\d+)')
      }
      
      # PermissionMan form events (CM may also handle forms)
      if match(.message, r'(?i)(form|permission|userform|formdistribution|formaudit)') {
        .event_type = "form"
        .event_category = "business"
        
        .form_id = match(.message, r'(?:form|formId)[\s:=]+(\d+)')
        .user_form_id = match(.message, r'(?:userform|userFormId)[\s:=]+(\d+)')
        .user_id = match(.message, r'(?:user|userId)[\s:=]+(\d+)')
        .school_id = match(.message, r'(?:school|schoolId)[\s:=]+(\d+)')
        .district_id = match(.message, r'(?:district|districtId)[\s:=]+(\d+)')
        .student_id = match(.message, r'(?:student|studentId)[\s:=]+(\d+)')
        .form_action = match(.message, r'(?i)(distributed|completed|submitted|expired|archived|created|updated|deleted)')
        .form_status = match(.message, r'(?:status|formStatus)[\s:=]+([a-zA-Z0-9_-]+)')
      }
      
      # Integration task events
      if match(.message, r'(?i)(integrationtask|fullintegration|deltaintegration|sistask)') {
        .event_type = "integration_task"
        .event_category = "integration"
        
        .integration_task_id = match(.message, r'(?:task|taskId|integrationTaskId)[\s:=]+(\d+)')
        .integration_type = match(.message, r'(?i)(full|delta|incremental)')
        .school_id = match(.message, r'(?:school|schoolId)[\s:=]+(\d+)')
        .district_id = match(.message, r'(?:district|districtId)[\s:=]+(\d+)')
        .integration_status = match(.message, r'(?i)(success|failed|error|completed|running|pending)')
      }
      
      # Ensure all IDs are integers (for MySQL join compatibility)
      if !is_null(.user_id) {
        .user_id, err = to_int(string!(.user_id))
        if !is_null(err) {
          .user_id = null
        }
      }
      if !is_null(.school_id) {
        .school_id, err = to_int(string!(.school_id))
        if !is_null(err) {
          .school_id = null
        }
      }
      if !is_null(.student_id) {
        .student_id, err = to_int(string!(.student_id))
        if !is_null(err) {
          .student_id = null
        }
      }
      # Convert student_ids array elements to integers (Vector 0.38.0 doesn't support map closures)
      # For now, keep as strings - they'll be converted during join operations if needed
      # if !is_null(.student_ids) {
      #   .student_ids = map(.student_ids, |id| { to_int(id) ?? null })
      # }
      if !is_null(.form_id) {
        .form_id, err = to_int(string!(.form_id))
        if !is_null(err) {
          .form_id = null
        }
      }
      if !is_null(.user_form_id) {
        .user_form_id, err = to_int(string!(.user_form_id))
        if !is_null(err) {
          .user_form_id = null
        }
      }
      if !is_null(.district_id) {
        .district_id, err = to_int(string!(.district_id))
        if !is_null(err) {
          .district_id = null
        }
      }
      if !is_null(.integration_task_id) {
        .integration_task_id, err = to_int(string!(.integration_task_id))
        if !is_null(err) {
          .integration_task_id = null
        }
      }
      
      # Add metadata
      .source_component = "tomcat"
      .host = get_env_var("HOSTNAME") ?? "app1"

  parse_tomcat_pfm:
    type: remap
    inputs:
      - tomcat_pfm
    source: |
      # Ensure .message is a string for all operations
      .message = string!(.message)
      
      # Same parsing logic as CM
      .timestamp = parse_timestamp(.message, format: "%Y-%m-%d %H:%M:%S") ?? now()
      # Extract log level
      if match(.message, r'ERROR') {
        .level = "error"
      } else if match(.message, r'WARN') {
        .level = "warn"
      } else if match(.message, r'INFO') {
        .level = "info"
      } else if match(.message, r'DEBUG') {
        .level = "debug"
      } else {
        .level = "unknown"
      }
      .event_type = "unknown"
      .event_category = "application"
      
      if match(.message, r'(?i)(login|authentication|auth|authenticate)') {
        .event_type = "authentication"
        .event_category = "security"
        .username = match(.message, r'(?:user|username|login)[\s:=]+([a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}|[a-zA-Z0-9._-]+)')
        if !is_null(.username) {
          .username = downcase(string!(.username))
          .username_normalized = replace(.username, r'@.*$', "")
        }
        .email = match(.message, r'([a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})')
        if !is_null(.email) {
          .email = downcase(string!(.email))
        }
        .client_ip = match(.message, r'\b(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\b')
        .auth_result = match(.message, r'(?i)(success|successful|failed|failure|denied|invalid)')
        if is_null(.auth_result) {
          .auth_result = "unknown"
        }
        if match(string!(.auth_result), r'(?i)(success|successful)') {
          .auth_result = "success"
        } else if match(string!(.auth_result), r'(?i)(failed|failure|denied|invalid)') {
          .auth_result = "failed"
        }
        .school_id = match(.message, r'(?:school|schoolId)[\s:=]+(\d+)')
        .school_subdomain = match(.message, r'https?://([a-z0-9-]+)\.schoolsoft\.(?:net|com)')
      }
      
      if match(.message, r'(?i)(powerschool|consumer|sis|integration)') {
        .event_type = "powerschool_integration"
        .event_category = "integration"
        .sis_identity = match(.message, r'(?:sis|external|powerschool)[\s:=]+([a-zA-Z0-9._-]+)')
        .email = match(.message, r'([a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})')
        if !is_null(.email) {
          .email = downcase(string!(.email))
        }
        .student_ids = match(.message, r'(?:student|studentId)[\s:=]+(\d+)')
        if is_string(.student_ids) {
          .student_ids = [.student_ids]
        } else if is_null(.student_ids) {
          .student_ids = []
        }
        .school_id = match(.message, r'(?:school|schoolId)[\s:=]+(\d+)')
        .integration_status = match(.message, r'(?i)(success|failed|error|completed)')
        if is_null(.integration_status) {
          .integration_status = "unknown"
        }
      }
      
      if match(.message, r'(?i)(conference|round|schedule|timeslot)') {
        .event_type = "conference"
        .event_category = "business"
        .user_id = match(.message, r'(?:user|userId)[\s:=]+(\d+)')
        .school_id = match(.message, r'(?:school|schoolId)[\s:=]+(\d+)')
        .student_id = match(.message, r'(?:student|studentId)[\s:=]+(\d+)')
      }
      
      if match(.message, r'(?i)(policy|policyresponse)') {
        .event_type = "policy"
        .event_category = "business"
        .user_id = match(.message, r'(?:user|userId)[\s:=]+(\d+)')
        .school_id = match(.message, r'(?:school|schoolId)[\s:=]+(\d+)')
        .student_id = match(.message, r'(?:student|studentId)[\s:=]+(\d+)')
      }
      
      # PermissionMan form events (PFM application)
      if match(.message, r'(?i)(form|permission|userform|formdistribution|formaudit)') {
        .event_type = "form"
        .event_category = "business"
        
        # Extract form-related identifiers
        .form_id = match(.message, r'(?:form|formId)[\s:=]+(\d+)')
        .user_form_id = match(.message, r'(?:userform|userFormId)[\s:=]+(\d+)')
        .user_id = match(.message, r'(?:user|userId)[\s:=]+(\d+)')
        .school_id = match(.message, r'(?:school|schoolId)[\s:=]+(\d+)')
        .district_id = match(.message, r'(?:district|districtId)[\s:=]+(\d+)')
        .student_id = match(.message, r'(?:student|studentId)[\s:=]+(\d+)')
        
        # Form action types
        .form_action = match(.message, r'(?i)(distributed|completed|submitted|expired|archived|created|updated|deleted)')
        
        # Form status
        .form_status = match(.message, r'(?:status|formStatus)[\s:=]+([a-zA-Z0-9_-]+)')
      }
      
      # Integration task events (FullIntegrationTask, DeltaIntegrationTask)
      if match(.message, r'(?i)(integrationtask|fullintegration|deltaintegration|sistask)') {
        .event_type = "integration_task"
        .event_category = "integration"
        
        .integration_task_id = match(.message, r'(?:task|taskId|integrationTaskId)[\s:=]+(\d+)')
        .integration_type = match(.message, r'(?i)(full|delta|incremental)')
        .school_id = match(.message, r'(?:school|schoolId)[\s:=]+(\d+)')
        .district_id = match(.message, r'(?:district|districtId)[\s:=]+(\d+)')
        .integration_status = match(.message, r'(?i)(success|failed|error|completed|running|pending)')
      }
      
      if !is_null(.user_id) {
        .user_id, err = to_int(string!(.user_id))
        if !is_null(err) {
          .user_id = null
        }
      }
      if !is_null(.school_id) {
        .school_id, err = to_int(string!(.school_id))
        if !is_null(err) {
          .school_id = null
        }
      }
      if !is_null(.student_id) {
        .student_id, err = to_int(string!(.student_id))
        if !is_null(err) {
          .student_id = null
        }
      }
      # Convert student_ids array elements to integers (Vector 0.38.0 doesn't support map closures)
      # For now, keep as strings - they'll be converted during join operations if needed
      # if !is_null(.student_ids) {
      #   .student_ids = map(.student_ids, |id| { to_int(id) ?? null })
      # }
      if !is_null(.form_id) {
        .form_id, err = to_int(string!(.form_id))
        if !is_null(err) {
          .form_id = null
        }
      }
      if !is_null(.user_form_id) {
        .user_form_id, err = to_int(string!(.user_form_id))
        if !is_null(err) {
          .user_form_id = null
        }
      }
      if !is_null(.district_id) {
        .district_id, err = to_int(string!(.district_id))
        if !is_null(err) {
          .district_id = null
        }
      }
      if !is_null(.integration_task_id) {
        .integration_task_id, err = to_int(string!(.integration_task_id))
        if !is_null(err) {
          .integration_task_id = null
        }
      }
      
      .source_component = "tomcat"
      .host = get_env_var("HOSTNAME") ?? "app2"

  # Parse HAProxy logs for HTTP traffic and authentication
  parse_haproxy_cm:
    type: remap
    inputs:
      - haproxy_cm
    source: |
      # HAProxy log format: client_ip:port [timestamp] frontend backend/server status_code bytes ...
      # Extract fields from HAProxy log format
      parsed = parse_apache_log(.message, format: "combined") ?? {}
      
      if !is_null(parsed.timestamp) {
        .timestamp = parsed.timestamp
      } else {
        .timestamp = now()
      }
      .client_ip = parsed.remote_addr
      .http_method = parsed.request_method
      .http_path = parsed.request
      .http_status = parsed.status
      .user_agent = parsed.agent
      
      # Ensure string types for matching operations
      if !is_null(.http_path) {
        .http_path = string!(.http_path)
      } else {
        .http_path = ""
      }
      if !is_null(.user_agent) {
        .user_agent = string!(.user_agent)
      } else {
        .user_agent = ""
      }
      
      # Extract school from URL path (for schools.id join)
      if .http_path != "" {
        .school_subdomain = match(.http_path, r'/([a-z0-9-]+)/')
        .school_id = match(.http_path, r'(?:school|schoolId)[\s:=/]+(\d+)')
        if !is_null(.school_id) {
          .school_id, err = to_int(string!(.school_id))
          if !is_null(err) {
            .school_id = null
          }
        }
      }
      
      # Device classification
      .device = "unknown"
      if .user_agent != "" {
        if match(.user_agent, r'(?i)(mobile|android|iphone|ipad)') {
          .device = "mobile"
        } else if match(.user_agent, r'(?i)(desktop|windows|mac|linux)') {
          .device = "desktop"
        }
      }
      
      # Authentication events from HTTP paths
      if .http_path != "" && match(.http_path, r'(?i)(login|auth|authenticate)') {
        .event_type = "authentication"
        .event_category = "security"
        
        # Extract username from path or query params
        .username = match(.http_path, r'(?:user|username|login)[=/]([a-zA-Z0-9._-]+)')
        if !is_null(.username) {
          .username = downcase(string!(.username))
          .username_normalized = replace(.username, r'@.*$', "")
        }
        
        # Auth result from HTTP status
        if .http_status == "200" {
          .auth_result = "success"
        } else if .http_status == "401" || .http_status == "403" {
          .auth_result = "failed"
        }
      } else {
        .event_type = "http_traffic"
        .event_category = "infrastructure"
      }
      
      .source_component = "haproxy"
      .host = get_env_var("HOSTNAME") ?? "app1"
      .app = "CM"

  parse_haproxy_pfm:
    type: remap
    inputs:
      - haproxy_pfm
    source: |
      parsed = parse_apache_log(.message, format: "combined") ?? {}
      if !is_null(parsed.timestamp) {
        .timestamp = parsed.timestamp
      } else {
        .timestamp = now()
      }
      .client_ip = parsed.remote_addr
      .http_method = parsed.request_method
      .http_path = parsed.request
      .http_status = parsed.status
      .user_agent = parsed.agent
      
      # Ensure string types for matching operations
      if !is_null(.http_path) {
        .http_path = string!(.http_path)
      } else {
        .http_path = ""
      }
      if !is_null(.user_agent) {
        .user_agent = string!(.user_agent)
      } else {
        .user_agent = ""
      }
      
      if .http_path != "" {
        .school_subdomain = match(.http_path, r'/([a-z0-9-]+)/')
        .school_id = match(.http_path, r'(?:school|schoolId)[\s:=/]+(\d+)')
        if !is_null(.school_id) {
          .school_id, err = to_int(string!(.school_id))
          if !is_null(err) {
            .school_id = null
          }
        }
      }
      .device = "unknown"
      if .user_agent != "" {
        if match(.user_agent, r'(?i)(mobile|android|iphone|ipad)') {
          .device = "mobile"
        } else if match(.user_agent, r'(?i)(desktop|windows|mac|linux)') {
          .device = "desktop"
        }
      }
      if .http_path != "" && match(.http_path, r'(?i)(login|auth|authenticate)') {
        .event_type = "authentication"
        .event_category = "security"
        .username = match(.http_path, r'(?:user|username|login)[=/]([a-zA-Z0-9._-]+)')
        if !is_null(.username) {
          .username = downcase(string!(.username))
          .username_normalized = replace(.username, r'@.*$', "")
        }
        if .http_status == "200" {
          .auth_result = "success"
        } else if .http_status == "401" || .http_status == "403" {
          .auth_result = "failed"
        }
      } else {
        .event_type = "http_traffic"
        .event_category = "infrastructure"
      }
      .source_component = "haproxy"
      .host = get_env_var("HOSTNAME") ?? "app2"
      .app = "PFM"

  # Parse Postfix mail logs
  parse_mail_cm:
    type: remap
    inputs:
      - mail_cm
    source: |
      # Ensure .message is a string for all operations
      .message = string!(.message)
      
      .timestamp = parse_timestamp(.message, format: "%b %d %H:%M:%S") ?? now()
      
      # Extract email outcome
      .event_type = "email"
      .event_category = "communication"
      
      # Extract recipient email (normalized for users.email and parents.email join)
      .recipient_email = match(.message, r'to=<([a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})>')
      if !is_null(.recipient_email) {
        .recipient_email = downcase(string!(.recipient_email))
      }
      
      # Extract sender
      .sender_email = match(.message, r'from=<([a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})>')
      if !is_null(.sender_email) {
        .sender_email = downcase(string!(.sender_email))
      }
      
      # Email outcome (sent, bounced, deferred, rejected)
      .email_outcome = "unknown"
      if match(.message, r'(?i)(sent|delivered)') {
        .email_outcome = "sent"
      } else if match(.message, r'(?i)(bounce|bounced)') {
        .email_outcome = "bounced"
      } else if match(.message, r'(?i)(defer|deferred)') {
        .email_outcome = "deferred"
      } else if match(.message, r'(?i)(reject|rejected)') {
        .email_outcome = "rejected"
      }
      
      # Extract message ID for correlation
      .message_id = match(.message, r'message-id=<([^>]+)>')
      
      .source_component = "postfix"
      .host = get_env_var("HOSTNAME") ?? "app1"
      .app = "CM"

  parse_mail_pfm:
    type: remap
    inputs:
      - mail_pfm
    source: |
      # Ensure .message is a string for all operations
      .message = string!(.message)
      
      .timestamp = parse_timestamp(.message, format: "%b %d %H:%M:%S") ?? now()
      .event_type = "email"
      .event_category = "communication"
      .recipient_email = match(.message, r'to=<([a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})>')
      if !is_null(.recipient_email) {
        .recipient_email = downcase(string!(.recipient_email))
      }
      .sender_email = match(.message, r'from=<([a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})>')
      if !is_null(.sender_email) {
        .sender_email = downcase(string!(.sender_email))
      }
      .email_outcome = "unknown"
      if match(.message, r'(?i)(sent|delivered)') {
        .email_outcome = "sent"
      } else if match(.message, r'(?i)(bounce|bounced)') {
        .email_outcome = "bounced"
      } else if match(.message, r'(?i)(defer|deferred)') {
        .email_outcome = "deferred"
      } else if match(.message, r'(?i)(reject|rejected)') {
        .email_outcome = "rejected"
      }
      .message_id = match(.message, r'message-id=<([^>]+)>')
      .source_component = "postfix"
      .host = get_env_var("HOSTNAME") ?? "app2"
      .app = "PFM"

  # Normalize all events for MySQL join compatibility
  normalize_identifiers:
    type: remap
    inputs:
      - parse_tomcat_cm
      - parse_tomcat_pfm
      - parse_haproxy_cm
      - parse_haproxy_pfm
      - parse_mail_cm
      - parse_mail_pfm
    source: |
      # Ensure consistent field naming for MySQL joins
      # Map to MySQL column names where applicable
      
      # User identifiers (for users table joins)
      if !is_null(.username) {
        if !is_null(.username_normalized) {
          .mysql_join_user_name = .username_normalized
        } else {
          .mysql_join_user_name = .username
        }
      }
      if !is_null(.email) {
        .mysql_join_user_email = .email
      }
      if !is_null(.recipient_email) {
        .mysql_join_user_email = .recipient_email
      }
      
      # ID fields (ensure integer type for MySQL joins)
      if !is_null(.user_id) {
        .mysql_join_user_id, err = to_int(string!(.user_id))
        if !is_null(err) {
          .mysql_join_user_id = null
        }
      }
      if !is_null(.school_id) {
        .mysql_join_school_id, err = to_int(string!(.school_id))
        if !is_null(err) {
          .mysql_join_school_id = null
        }
      }
      if !is_null(.student_id) {
        .mysql_join_student_id, err = to_int(string!(.student_id))
        if !is_null(err) {
          .mysql_join_student_id = null
        }
      }
      
      # PermissionMan-specific identifiers
      if !is_null(.form_id) {
        .mysql_join_form_id, err = to_int(string!(.form_id))
        if !is_null(err) {
          .mysql_join_form_id = null
        }
      }
      if !is_null(.user_form_id) {
        .mysql_join_user_form_id, err = to_int(string!(.user_form_id))
        if !is_null(err) {
          .mysql_join_user_form_id = null
        }
      }
      if !is_null(.district_id) {
        .mysql_join_district_id, err = to_int(string!(.district_id))
        if !is_null(err) {
          .mysql_join_district_id = null
        }
      }
      if !is_null(.integration_task_id) {
        .mysql_join_integration_task_id, err = to_int(string!(.integration_task_id))
        if !is_null(err) {
          .mysql_join_integration_task_id = null
        }
      }
      
      # Add join hints for Grafana queries
      # Build array with explicit error handling for concatenation
      .mysql_joins = []
      if !is_null(.mysql_join_user_id) {
        .mysql_joins, err = .mysql_joins + ["users.id"]
        if is_null(err) {
          .mysql_joins, err = .mysql_joins + ["permissionMan.User.id"]
        }
      }
      if !is_null(.mysql_join_user_name) {
        .mysql_joins, err = .mysql_joins + ["users.userName"]
        if is_null(err) {
          .mysql_joins, err = .mysql_joins + ["permissionMan.User.userName"]
        }
      }
      if !is_null(.mysql_join_user_email) {
        .mysql_joins, err = .mysql_joins + ["users.email"]
        if is_null(err) {
          .mysql_joins, err = .mysql_joins + ["permissionMan.User.email"]
        }
      }
      if !is_null(.mysql_join_school_id) {
        .mysql_joins, err = .mysql_joins + ["schools.id"]
        if is_null(err) {
          .mysql_joins, err = .mysql_joins + ["permissionMan.School.id"]
        }
      }
      if !is_null(.mysql_join_student_id) {
        .mysql_joins, err = .mysql_joins + ["students.id"]
        if is_null(err) {
          .mysql_joins, err = .mysql_joins + ["permissionMan.Student.id"]
        }
      }
      if !is_null(.mysql_join_form_id) {
        .mysql_joins, err = .mysql_joins + ["permissionMan.Form.id"]
      }
      if !is_null(.mysql_join_user_form_id) {
        .mysql_joins, err = .mysql_joins + ["permissionMan.UserForm.id"]
      }
      if !is_null(.mysql_join_district_id) {
        .mysql_joins, err = .mysql_joins + ["permissionMan.District.id"]
      }
      if !is_null(.mysql_join_integration_task_id) {
        .mysql_joins, err = .mysql_joins + ["permissionMan.FullIntegrationTask.id"]
        if is_null(err) {
          .mysql_joins, err = .mysql_joins + ["permissionMan.DeltaIntegrationTask.id"]
        }
      }
      
      # Standardize timestamp format
      .@timestamp = .timestamp
      
      # Add MOAD metadata
      .moad_version = "1.0"
      .moad_join_compatible = true

# ============================================================================
# SINKS - Output to Loki and structured files
# ============================================================================

sinks:
  # Send to Loki for log aggregation
  loki_all:
    type: loki
    inputs:
      - normalize_identifiers
    endpoint: http://loki:3100
    encoding:
      codec: json
    labels:
      app: "{{ app }}"
      host: "{{ host }}"
      event_type: "{{ event_type }}"
      event_category: "{{ event_category }}"
      source_component: "{{ source_component }}"
    healthcheck:
      enabled: true

  # Write structured JSON logs for archival and analysis
  structured_files:
    type: file
    inputs:
      - normalize_identifiers
    path: /var/lib/vector/structured/vector-%Y-%m-%d.jsonl
    encoding:
      codec: json
    compression: gzip
    buffer:
      type: disk
      max_size: 314572800  # 300MB (minimum required is 256MB)
      when_full: block

